<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Hibernate | Developer's Notes]]></title>
  <link href="http://dmitry-at-hyla.github.io/blog/categories/hibernate/atom.xml" rel="self"/>
  <link href="http://dmitry-at-hyla.github.io/"/>
  <updated>2019-06-24T10:15:42-05:00</updated>
  <id>http://dmitry-at-hyla.github.io/</id>
  <author>
    <name><![CDATA[Dmitry Antonyuk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[The Bug of the Week: Sequence Magic]]></title>
    <link href="http://dmitry-at-hyla.github.io/blog/2019/05/17/the-bug-of-the-week-sequence-magic/"/>
    <updated>2019-05-17T22:34:42-05:00</updated>
    <id>http://dmitry-at-hyla.github.io/blog/2019/05/17/the-bug-of-the-week-sequence-magic</id>
    <content type="html"><![CDATA[<h2>Prelude</h2>

<p>I&rsquo;ve been working on moving SpringBoot applications to SpringCloud. It&rsquo;s a complex task including libraries upgrade, infrastructure adjustment, changing the way we handle settings etc. As a part of this task SpringBoot should be migrated to 2nd version.</p>

<p>Once I&rsquo;m done with an application, I test it, deploy to the dev environment, test it again there (not really much, sometimes it&rsquo;s just checking logs and hitting a few endpoints using curl). If I&rsquo;m happy, the application is going further to the qa environment, so I can forget about it. For a little while. Well, you know how it goes.</p>

<h2>The Thing Comes Up</h2>

<p>On a daily meeting my collegue reported an issue she ran into while testing her code in the dev environment. Violation of primary key constraint, nothing out of the ordinary. We already experienced similar issues, so she got the most reasonable advice: check sequences, reset them if needed. Maybe database restore was made incorrectly. It happens.</p>

<p>As it was mentioned before there was a lot of changes made in order to migrate the application to SpringCloud. The changes were not related to the sequences, or the persistence layer at all. But there was a lot of changes, I concerned and my collegue got one more advice: test her changes on a stable branch. Just to make sure, it&rsquo;s not my changes. They should not, I was pretty certain. But
who knows.</p>

<h2>We Found the Source</h2>

<p>Next day the collegue found out that a stable branch is working, and the issue is showing up only in my feature branch. Getting into the issue we&rsquo;ve found that the application tries to insert a record along with an ID that is less than sequence&rsquo;s last value.</p>

<p>OK, the data issue theory is wrong. The main difference between these two branches is that upgraded SpringBoot was in use. Quick googling showed that Hibernate uses an optimization for sequence AUTO strategy, and suggested to turn optimization off with a flag:</p>

<pre><code>hibernate.id.new_generator_mappings = false
</code></pre>

<p>Which could be reached in SpringBoot using</p>

<pre><code class="yaml">spring:
  jpa:
    hibernate:
      use-new-id-generator-mappings = false
</code></pre>

<p>The problem was that we don&rsquo;t use AUTO strategy but SEQUENCE. Anyway I tested this solution just in case and it worked. Strange, isn&rsquo;t it?</p>

<h2>The Exploration</h2>

<p>To grok that behavior we went through the Hibernate documentation, codebase and several posts on the internet. This is what we got:</p>

<p>SEQUENCE uses seqhilo optimization by default which works this way:</p>

<ul>
<li>Let&rsquo;s say DB sequence has an increment N</li>
<li>The sequence is called for the next value, let&rsquo;s call it hi</li>
<li>Hibernate uses identfiers range [(hi - 1) * N, hi * N)</li>
<li>As soon as all the identifiers are used, repeat the loop</li>
</ul>


<p>Assuming that current value is 1 and increment is 10, next hi is going to be 11, so values from 1 to 10 are going to be used for the identifiers without hitting the database.</p>

<p>If an increment is 1, the identifiers range is just [hi - 1, hi) which means that it contains the only value and it works as a regular DB sequence. And this is exactly what was in place before the migration.</p>

<p>This part was well-known, but what I didn&rsquo;t know is that
* Hibernate 3.2.3 <a href="http://in.relation.to/2007/04/10/new-323-hibernate-identifier-generators/">introduced</a> new enhanced optimizers in order to allow other non-hibernate applications use same sequence.
* Since Hibernate 4 it&rsquo;s possible to enable these optimizers for AUTO, SEQUENCE and TABLE generators with <code>hibernate.id.new_generator_mappings</code> property set to true.
* Starting with Hibernate 5 this property set to true by default.</p>

<p>Now the most interesting part comes.</p>

<p>We used SpringBoot 1.4.5 which uses Hibernate 5. That part that I was not able to get. Hibernate 5 uses enhanced generators by default, so old version should fail as well, right? My other collegue helped me with it. She mentioned that SpringBoot 1.4.5 turns the legacy behavior back. That why old code worked. But <a href="https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.0-Migration-Guide#id-generator">SpringBoot 2 uses Hibernate default behavior</a> now. And that&rsquo;s the exact reason why we got it after migration.</p>

<p>One more thing. Since we use JPA, Hibernate takes the value for increment from the <a href="https://docs.oracle.com/javaee/5/api/javax/persistence/SequenceGenerator.html#allocationSize%28%29">SequenceGenerator::allocationSize</a> property.</p>

<h2>Possible Solutions</h2>

<p>Having said that, following solutions could be used:</p>

<ul>
<li>turn on legacy behavior with the Hibernate or Spring flag set to false</li>
<li>use allocationSize equals to 1</li>
<li>set DB sequence&rsquo;s increment to 50 (default allocationSize value)</li>
<li>specify <code>none</code> optimizer for the generator</li>
<li>set IDENTITY generator if ID column is auto-incremented</li>
</ul>

]]></content>
  </entry>
  
</feed>
